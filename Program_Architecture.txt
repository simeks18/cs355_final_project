Program will use an ncurses GUI to create a password-based file explorer with symmetric cipher encryption and decryption capabilities.

Components:

1. XOR Cipher (Primary encryption algorithm)
2. Vigenère Cipher (Secondary encryption using a keyword to encrypt a message)
3. Security: Password hashing (SHA-256) and a nonce serving as a unique key for each file
4. Integrity verified with HMAC-SHA256 (We need to store the HMAC signature inside the encrypted file to ensure that the password is correct at time of decryption)

Program Design - Efficacy

1. User provides master password upon each session
2. Password is hashed with SHA-256 to generate the encryption key
3. Key is regenerated from password each session and key is not stored on the disk and IS portable
4. Generate keys for different encryption methods based on this hashed password
5. A nonce (number used once) is generated for every file to be encrypted, ensuring each file has a unique encryption pattern


Program Design - File Handling 

Encryption Process:

1. Get the password from the user
2. Using the user password, generate the key (The user provides the password and the password is hashed the same way that it is during the encryption process. We can hash with SHA-256 to produce a fixed length output with variable length input)
3. Generate a nonce (set field length at 16 bytes - a nonce is just a random number that doesn't need to be secret, just unique)
4. Open input file and create output file
5. The file is encrypted and prefixed with a 5 byte header: Header Contents (Little endian): Magic Number identifying file as encrypted (2 bytes) | Algorithm ID / Pointer to encryption method used (1 byte) | Nonce (16 bytes)
6. Take in a bit array to perform the bitwise operation XORing the input + key + nonce (for XOR cipher) or apply Vigenère transformation
7. Generate HMAC-SHA256 signature using the secret key on the entire encrypted content
8. Append the 32-byte HMAC signature to the end of the file as a footer

Decryption Process:

1. Prompt user for password
2. Hash the password with SHA-256 to regenerate the 32-byte secret key (This is symmetric and done the same way for encryption as it is for decryption)
3. Open the file
4. Verify the password by reading the last 32 bytes of the file to get the stored_hmac
5. Calculate a new_hmac on everything else in the file (from bytes 0 to the HMAC) using the secret key
6. If the HMAC values don't match, then do not proceed with the decryption
7. If the HMAC is good, then read the first two bytes and verify the magic number to confirm this is an encrypted file
8. Read the algorithm ID to identify which encryption method was used
9. Read the 16-byte nonce
10. Use the function pointer array (Array of function pointers) to call the corresponding decryption routine based on algorithm ID
11. Decrypt the file: Plaintext Byte = Encrypted Byte XOR w/key and again XOR w/Nonce (or apply inverse Vigenère transformation)
12. Write the decrypted file to output
